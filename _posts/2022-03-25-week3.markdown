---
layout: post
title:  "week3"
date:   2022-03-25 00:16:30 +0900
categories: 컴퓨터알고리즘
---
## 분할 정복 알고리즘
- 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘
- 분할된 입력에 대한 문제를 부분 문제라고 하고, 부분 문제의 해를 부분 해라 한다.
### 1. 합병정렬(Merge Sort)
#### - 입력이 2개의 부분 문제로 분할되고, 부분 문제의 크기가 1/2로 감소하는 분할정복 알고리즘
#### - 각각의 부분 문제를 재귀적으로 합병 정렬한 후, 2개의 정렬된 부분을 합병하여 정렬(정복)한다.
#### - 시간복잡도는 O(nlogn)
### 2. 퀵정렬(Quick Sort)
#### - 분할정복알고리즘으로 분류되나, 사실 알고리즘이 수행 되는 과정을 살펴보면 정복 후 분할하는 것
#### - 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할정복 알고리즘
#### - 피봇을 기준으로 작은 숫자 왼편, 큰 숫자 오른편에 위치하도록 분할하고 피봇을 그 사이에 놓는다.
#### - 분할된 부분문제들에 대해서도 동일한 과정을 재귀적으로 수행하여 정렬한다.
#### - 시간복잡도는 O(nlogn), 최악 시간복잡도는 O(n^2)
```python

from typing import MutableSequence

def qsort(a: MutableSequence, left: int, right: int) -> None:
	pl = left
	pr = right
	x = a[(left+right) // 2]

	while pl <= pr :
		while a[pl] < x: pl += 1
		while a[pr] > x: pr -= 1
		if pl <= pr :
			a[pl], a[pr] = a[pr], a[pl]
			pl += 1
			pr -= 1

	if left < pr: qsort(a, left, pr)
	if pl < right: qsort(a, pl, right)

def quick_sort(a: MutableSequence) -> NONE:
	qsort(a, 0, len(a) - 1)

```

### 3. 선택(Selection)
#### - k번째 작은 수를 찾는 문제로서, 입력에서 퀵 정렬과 같이 피봇을 선택하여 피봇보다 작은 부분과 큰 부분으로 분할
#### - k번째 작은 수가 들어있는 부분을 재귀적으로 탐색
#### - 평균 시간복잡도는 O(n)
### 4. 최근접 점의 쌍(Closest Pair)
#### - n개의 점들을 1/2로 분할하여 각각의 부분문제에서 최근접 점의 쌍을 찾는다
#### - 2개의 부분해 중에서 짧은 거리를 가진 점의 쌍을 일단 찾는다
#### - 그리고 2개의 부분해를 취합할 때, 반드시 중간영역 안에 있는 점들 중에 최근접 점의 쌍이 있는지 확인
#### - 향상된 알고리즘의 시간복잡도는 O(nlogn)
### 5. 분할정복이 부적절한 경우
#### - 입력이 분할될 때마다 분할된 부분문제들의 입력 크기의 합이 분할되기 전의 입력 크기보다 커지는 경우


